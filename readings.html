<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reading Page</title>
  <!-- Load PDF.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <style>
    body {
  font-family: Arial, sans-serif;
  margin: 0;
  background: #f9f9f9;
  color: #222;
  transition: background 0.3s, color 0.3s;
}

/* Navbar */
.navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #111;
  color: white;
  padding: 10px 20px;
}

.navbar nav a {
  margin: 0 10px;
  color: white;
  text-decoration: none;
}

.search {
  padding: 5px;
  border-radius: 5px;
  border: none;
}

/* Chapter Header */
.chapter-header {
  background: white;
  margin: 20px auto;
  padding: 20px;
  max-width: 800px;
  border-radius: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  text-align: center;
}

.chapter-header h1 {
  font-size: 22px;
  margin: 10px 0;
}

.meta {
  font-size: 14px;
  color: gray;
  margin: 10px 0;
}

/* Reading Content */
.content {
  max-width: 800px;
  margin: auto;
  padding: 20px;
  line-height: 1.8;
  font-size: 18px;
  background: white;
  border-radius: 8px;
  transition: background 0.3s, color 0.3s, font-size 0.3s, line-height 0.3s;
}

/* PDF Container */
#pdfContainer {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  border: 2px solid #4CAF50 !important; /* Debug border */
  background: white !important;
}

#pdf-canvas {
  max-width: 100%;
  height: auto;
  border: 2px solid #FF5722 !important; /* Debug border */
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  margin-bottom: 20px;
  background: white !important;
  display: block !important;
  visibility: visible !important;
}

.pdf-controls {
  margin: 15px 0;
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 15px;
  flex-wrap: wrap;
}

.pdf-controls button {
  padding: 8px 16px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
}

.pdf-controls button:disabled {
  background: #6c757d;
  cursor: not-allowed;
}

.page-info {
  font-size: 16px;
  font-weight: bold;
}

/* Loading Spinner */
.loading {
  display: none;
  text-align: center;
  padding: 40px;
  font-size: 18px;
  color: #666;
}

.spinner {
  border: 4px solid #f3f3f3;
  border-top: 4px solid #007bff;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 0 auto 20px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Error Message */
.error-message {
  display: none;
  text-align: center;
  padding: 40px;
  background: #f8d7da;
  color: #721c24;
  border-radius: 8px;
  margin: 20px auto;
  max-width: 800px;
}

/* Floating Buttons */
.floating-btns {
  position: fixed;
  right: 20px;
  bottom: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  z-index: 1000;
}

.fab {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: none;
  color: white;
  font-size: 20px;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.purple { background: purple; }
.green { background: green; }
.red { background: crimson; }
.blue { background: dodgerblue; }

/* Panels */
.settings-panel {
  position: fixed;
  background: white;
  padding: 15px;
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  width: 280px;
  max-height: 400px;
  overflow-y: auto;
  display: none;
  z-index: 1001;
  right: 80px;
  bottom: 180px;
}

.settings-panel h3 {
  margin-top: 0;
  font-size: 18px;
}

.settings-panel label {
  display: block;
  margin: 10px 0 5px;
}

/* Dark mode */
.dark-mode {
  background: #222 !important;
  color: #f1f1f1 !important;
}

.dark-mode .content {
  background: #333 !important;
  color: #f1f1f1 !important;
}

.dark-mode #pdfContainer {
  background: #333 !important;
}

.dark-mode .settings-panel {
  background: #333 !important;
  color: #f1f1f1 !important;
}

.zoom-controls {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 10px 0;
}

.zoom-controls button {
  padding: 5px 10px;
  background: #28a745;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
}

.access-denied {
  text-align: center;
  padding: 40px;
  background: #fff3cd;
  color: #856404;
  border-radius: 8px;
  margin: 20px auto;
  max-width: 600px;
}

.purchase-btn {
  padding: 10px 20px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  font-size: 16px;
  margin-top: 15px;
}

    
  </style>
</head>
<body>
  <!-- Navbar -->
  <header class="navbar">
    <div class="logo">üìö MyLibrary</div>
    <nav>
      <a href="library.html">‚Üê Back to Library</a>
    </nav>
    <div id="bookInfo" style="color: white; font-size: 14px;"></div>
  </header>

  <!-- Loading Spinner -->
  <div class="loading" id="loadingSpinner">
    <div class="spinner"></div>
    <p>Loading book...</p>
  </div>

  <!-- Error Message -->
  <div class="error-message" id="errorMessage">
    <h3>Error Loading Book</h3>
    <p id="errorText"></p>
    <button onclick="window.location.href='library.html'" style="margin-top: 10px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">
      Back to Library
    </button>
  </div>

  <!-- Access Denied Message -->
  <div class="access-denied" id="accessDenied" style="display: none;">
    <h3>üîí Access Required</h3>
    <p>You need to purchase this book to read it.</p>
    <button class="purchase-btn" id="purchaseBtn">Purchase Book</button>
  </div>

  <!-- Chapter Header -->
  <section class="chapter-header" id="chapterHeader" style="display: none;">
    <h1 id="bookTitle">Loading Book...</h1>
    <div class="meta">
      <span id="bookMeta">Loading book information...</span>
    </div>
  </section>

  <!-- PDF Viewer -->
  <div class="pdf-container" id="pdfContainer" style="display: none;">
    <canvas id="pdf-canvas"></canvas>
    <div class="zoom-controls">
      <button id="zoomOut">Zoom Out</button>
      <span id="zoomLevel">100%</span>
      <button id="zoomIn">Zoom In</button>
    </div>
    <div class="pdf-controls">
      <button class="btn blue" id="prevPage">‚Üê Previous Page</button>
      <span class="page-info">Page <span id="currentPage">1</span> of <span id="totalPages">0</span></span>
      <button class="btn blue" id="nextPage">Next Page ‚Üí</button>
    </div>
  </div>

  <!-- Floating Buttons -->
  <div class="floating-btns">
    <button class="fab purple" id="settingsFab">‚öô</button>
    <button class="fab red" id="saveFab">‚ù§Ô∏è</button>
    <button class="fab blue" id="scrollTop">‚¨Ü</button>
  </div>

  <!-- Settings Panel -->
  <div class="settings-panel" id="settingsPanel">
    <h3>‚öô Reader Settings</h3>
    <label>Zoom Level:</label>
    <input type="range" id="zoomControl" min="50" max="200" value="100">
    <label>
      <input type="checkbox" id="darkModeToggle"> Dark Mode
    </label>
  </div>

  <script>
    // PDF.js configuration
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    // DOM elements (keep all existing element references)
    const scrollBtn = document.getElementById("scrollTop");
    const settingsFab = document.getElementById("settingsFab");
    const settingsPanel = document.getElementById("settingsPanel");
    const saveFab = document.getElementById("saveFab");
    const pdfContainer = document.getElementById("pdfContainer");
    const pdfCanvas = document.getElementById("pdf-canvas");
    const prevPageBtn = document.getElementById("prevPage");
    const nextPageBtn = document.getElementById("nextPage");
    const currentPageEl = document.getElementById("currentPage");
    const totalPagesEl = document.getElementById("totalPages");
    const loadingSpinner = document.getElementById("loadingSpinner");
    const errorMessage = document.getElementById("errorMessage");
    const errorText = document.getElementById("errorText");
    const chapterHeader = document.getElementById("chapterHeader");
    const bookTitle = document.getElementById("bookTitle");
    const bookMeta = document.getElementById("bookMeta");
    const bookInfo = document.getElementById("bookInfo");
    const zoomControl = document.getElementById("zoomControl");
    const zoomInBtn = document.getElementById("zoomIn");
    const zoomOutBtn = document.getElementById("zoomOut");
    const zoomLevel = document.getElementById("zoomLevel");
    const accessDenied = document.getElementById("accessDenied");
    const purchaseBtn = document.getElementById("purchaseBtn");

    // PDF variables
    let pdfDoc = null;
    let currentPdfPage = 1;
    let currentScale = 1.0;
    let currentBookId = null;
    let currentBookData = null;
    const ctx = pdfCanvas.getContext('2d');

    // Get book ID from URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const bookId = urlParams.get('bookId');
    currentBookId = bookId;

    // API configuration - FIXED: Remove duplicate /api
    const API_BASE_URL = 'http://127.0.0.1:8080';
    const BOOKS_API_URL = `${API_BASE_URL}/api/books`;
    const PAYMENTS_API_URL = `${API_BASE_URL}/api/payments`;

    // Function to get JWT token from localStorage
    function getAuthToken() {
        return localStorage.getItem('jwt') || localStorage.getItem('token');
    }

    // Function to create headers with authentication
    function createHeaders() {
        const token = getAuthToken();
        const headers = {
            'Content-Type': 'application/json'
        };
        
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }
        
        return headers;
    }

    // Function to create headers for PDF stream (without Content-Type for binary data)
    function createPdfHeaders() {
        const token = getAuthToken();
        const headers = {};
        
        if (token) {
            headers['Authorization'] = `Bearer ${token}`;
        }
        
        return headers;
    }

    // Show loading spinner
    function showLoading(show) {
        loadingSpinner.style.display = show ? 'block' : 'none';
        if (show) {
            pdfContainer.style.display = 'none';
            chapterHeader.style.display = 'none';
            errorMessage.style.display = 'none';
            accessDenied.style.display = 'none';
        }
    }

    // Show error message
    function showError(message) {
        errorText.textContent = message;
        errorMessage.style.display = 'block';
        loadingSpinner.style.display = 'none';
        pdfContainer.style.display = 'none';
        chapterHeader.style.display = 'none';
        accessDenied.style.display = 'none';
    }

    // Show access denied message
    function showAccessDenied() {
        accessDenied.style.display = 'block';
        loadingSpinner.style.display = 'none';
        pdfContainer.style.display = 'none';
        chapterHeader.style.display = 'none';
        errorMessage.style.display = 'none';
    }

    // Get book data from the list of books
    async function getBookData(bookId) {
        try {
            const response = await fetch(`${BOOKS_API_URL}?page=0&size=100`, {
                method: 'GET',
                headers: createHeaders()
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            const books = data.content || [];
            
            // Find the book by ID
            const book = books.find(b => b.id == bookId);
            if (!book) {
                throw new Error('Book not found in the library');
            }
            
            return book;
        } catch (error) {
            console.error('Error fetching book data:', error);
            throw error;
        }
    }

    // Check if user has access to the book
    async function checkBookAccess(bookId) {
        try {
            const response = await fetch(`${PAYMENTS_API_URL}/access/${bookId}`, {
                method: 'GET',
                headers: createHeaders()
            });
            
            if (response.ok) {
                const hasAccess = await response.json();
                return hasAccess;
            } else if (response.status === 403) {
                return false;
            } else {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        } catch (error) {
            console.error('Error checking book access:', error);
            return false;
        }
    }

    // Load book data and PDF from backend
    async function loadBook() {
        if (!bookId) {
            showError('No book ID provided in URL.');
            return;
        }

        showLoading(true);

        try {
            // Get book data
            currentBookData = await getBookData(bookId);
            
            // Update page title and book info
            document.title = `Reading: ${currentBookData.title}`;
            bookTitle.textContent = currentBookData.title;
            bookInfo.textContent = `${currentBookData.title} by ${currentBookData.author}`;
            bookMeta.textContent = `By ${currentBookData.author} | ${currentBookData.numberOfPages || 'N/A'} pages | ${currentBookData.accessType === 'FREE' ? 'Free' : 'Paid'}`;

            // Check if user has access
            const hasAccess = await checkBookAccess(bookId);
            const isFree = currentBookData.accessType === 'FREE';

            if (!hasAccess && !isFree) {
                showAccessDenied();
                return;
            }

            // Now get the PDF reading URL
            const readUrlResponse = await fetch(`${BOOKS_API_URL}/read/url/${bookId}`, {
                method: 'GET',
                headers: createHeaders()
            });

            if (!readUrlResponse.ok) {
                if (readUrlResponse.status === 403) {
                    showAccessDenied();
                    return;
                } else {
                    throw new Error('Failed to get reading URL');
                }
            }

            const readUrlData = await readUrlResponse.json();
            
            // FIXED: Handle the PDF URL correctly - it should be a full URL or relative path
            let pdfUrl;
            if (readUrlData.pdfUrl.startsWith('http')) {
                // If it's already a full URL, use it as is
                pdfUrl = readUrlData.pdfUrl;
            } else if (readUrlData.pdfUrl.startsWith('/')) {
                // If it starts with /, prepend the base URL
                pdfUrl = `${API_BASE_URL}${readUrlData.pdfUrl}`;
            } else {
                // Otherwise, assume it's relative to the API base
                pdfUrl = `${API_BASE_URL}/api/books${readUrlData.pdfUrl.startsWith('/') ? '' : '/'}${readUrlData.pdfUrl}`;
            }

            console.log('Loading PDF from URL:', pdfUrl); // Debug log

            // Load the PDF
            await loadPdfFromUrl(pdfUrl);
            
            // Show the content
            chapterHeader.style.display = 'block';
            pdfContainer.style.display = 'block';
            showLoading(false);

        } catch (error) {
            console.error('Error loading book:', error);
            showError('Failed to load book: ' + error.message);
        }
    }

    // Load PDF from backend URL - FIXED version
    async function loadPdfFromUrl(pdfUrl) {
    try {
        showLoading(true);
        
        console.log('Attempting to load PDF from:', pdfUrl);
        
        // Load PDF with authentication headers
        pdfDoc = await pdfjsLib.getDocument({
            url: pdfUrl,
            httpHeaders: createPdfHeaders()
        }).promise;
        
        console.log('PDF loaded successfully, total pages:', pdfDoc.numPages);
        
        totalPagesEl.textContent = pdfDoc.numPages;
        currentPdfPage = 1;
        currentPageEl.textContent = currentPdfPage;
        currentScale = 1.5; // Increased for better visibility
        zoomControl.value = 150;
        zoomLevel.textContent = '150%';
        
        // FIX: Ensure containers are visible BEFORE rendering
        chapterHeader.style.display = 'block';
        pdfContainer.style.display = 'block';
        pdfContainer.style.visibility = 'visible';
        pdfContainer.classList.add('active');
        
        // Force a reflow to ensure CSS is applied
        pdfContainer.offsetHeight;
        
        await renderPdfPage(currentPdfPage);
        
        showLoading(false);
        
    } catch (error) {
        console.error('Error loading PDF:', error);
        // Try alternative approach if direct PDF loading fails
        await tryAlternativePdfLoad(pdfUrl);
    }
}


    // Alternative PDF loading method
    async function tryAlternativePdfLoad(pdfUrl) {
        try {
            console.log('Trying alternative PDF loading method...');
            
            // Fetch the PDF as blob first
            const response = await fetch(pdfUrl, {
                method: 'GET',
                headers: createPdfHeaders()
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const pdfBlob = await response.blob();
            const blobUrl = URL.createObjectURL(pdfBlob);
            
            // Load from blob URL
            pdfDoc = await pdfjsLib.getDocument(blobUrl).promise;
            
            console.log('PDF loaded via blob method, total pages:', pdfDoc.numPages);
            
            totalPagesEl.textContent = pdfDoc.numPages;
            currentPdfPage = 1;
            currentPageEl.textContent = currentPdfPage;
            currentScale = 1.0;
            zoomControl.value = 100;
            zoomLevel.textContent = '100%';
            
            await renderPdfPage(currentPdfPage);
            
        } catch (error) {
            console.error('Alternative PDF loading also failed:', error);
            throw new Error('Failed to load PDF file from server: ' + error.message);
        }
    }

    // Render PDF page (keep existing implementation)
    async function renderPdfPage(pageNum) {
    if (!pdfDoc || pageNum < 1 || pageNum > pdfDoc.numPages) return;
    
    showLoading(true);
    
    try {
        const page = await pdfDoc.getPage(pageNum);
        const viewport = page.getViewport({ scale: currentScale });
        
        // FIX: Ensure canvas is properly sized and visible
        pdfCanvas.width = viewport.width;
        pdfCanvas.height = viewport.height;
        pdfCanvas.style.display = 'block';
        pdfCanvas.style.visibility = 'visible';
        pdfCanvas.style.width = '100%';
        pdfCanvas.style.height = 'auto';
        
        console.log(`Rendering page ${pageNum} at ${viewport.width}x${viewport.height}`);
        
        const renderContext = {
            canvasContext: ctx,
            viewport: viewport
        };
        
        await page.render(renderContext).promise;
        currentPdfPage = pageNum;
        currentPageEl.textContent = currentPdfPage;
        
        // Update button states
        prevPageBtn.disabled = currentPdfPage <= 1;
        nextPageBtn.disabled = currentPdfPage >= pdfDoc.numPages;
        
        console.log('Page rendered successfully');
        
    } catch (error) {
        console.error('Error rendering PDF page:', error);
        showError('Error displaying PDF page: ' + error.message);
    }
    
    showLoading(false);
}


    // Initiate payment for the book (keep existing implementation)
    async function initiatePayment() {
        if (!currentBookId) return;
        
        try {
            const response = await fetch(`${PAYMENTS_API_URL}/create`, {
                method: 'POST',
                headers: createHeaders(),
                body: JSON.stringify({
                    bookId: currentBookId,
                    durationDays: 30
                })
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.sessionUrl) {
                    window.location.href = data.sessionUrl;
                } else {
                    showError('Payment session URL not received.');
                }
            } else {
                const errorText = await response.text();
                showError('Failed to initiate payment: ' + errorText);
            }
        } catch (error) {
            console.error('Error initiating payment:', error);
            showError('Error initiating payment.');
        }
    }

    // Event listeners (keep all existing event listeners)
    prevPageBtn.addEventListener('click', () => {
        if (currentPdfPage > 1) {
            renderPdfPage(currentPdfPage - 1);
        }
    });

    nextPageBtn.addEventListener('click', () => {
        if (currentPdfPage < pdfDoc.numPages) {
            renderPdfPage(currentPdfPage + 1);
        }
    });

    purchaseBtn.addEventListener('click', initiatePayment);

    zoomControl.addEventListener('input', (e) => {
        currentScale = parseInt(e.target.value) / 100;
        zoomLevel.textContent = e.target.value + '%';
        renderPdfPage(currentPdfPage);
    });

    zoomInBtn.addEventListener('click', () => {
        const newZoom = Math.min(200, parseInt(zoomControl.value) + 10);
        zoomControl.value = newZoom;
        currentScale = newZoom / 100;
        zoomLevel.textContent = newZoom + '%';
        renderPdfPage(currentPdfPage);
    });

    zoomOutBtn.addEventListener('click', () => {
        const newZoom = Math.max(50, parseInt(zoomControl.value) - 10);
        zoomControl.value = newZoom;
        currentScale = newZoom / 100;
        zoomLevel.textContent = newZoom + '%';
        renderPdfPage(currentPdfPage);
    });

    function saveProgress() {
        if (!currentBookId) return;
        localStorage.setItem(`book_${currentBookId}_page`, currentPdfPage);
        localStorage.setItem(`book_${currentBookId}_zoom`, currentScale);
        alert(`‚úÖ Saved progress at page ${currentPdfPage}`);
    }
    saveFab.addEventListener("click", saveProgress);

    function loadSavedProgress() {
        if (!currentBookId) return;
        const savedPage = localStorage.getItem(`book_${currentBookId}_page`);
        const savedZoom = localStorage.getItem(`book_${currentBookId}_zoom`);
        
        if (savedPage) {
            currentPdfPage = parseInt(savedPage);
        }
        if (savedZoom) {
            currentScale = parseFloat(savedZoom);
            zoomControl.value = Math.round(currentScale * 100);
            zoomLevel.textContent = zoomControl.value + '%';
        }
    }

    scrollBtn.addEventListener("click", () => {
        window.scrollTo({ top: 0, behavior: "smooth" });
    });

    function toggleSettings() {
        settingsPanel.style.display = settingsPanel.style.display === "block" ? "none" : "block";
    }

    settingsFab.addEventListener("click", toggleSettings);

    document.addEventListener('click', function(event) {
        if (!event.target.closest('.settings-panel') && !event.target.closest('#settingsFab')) {
            settingsPanel.style.display = 'none';
        }
    });

    document.getElementById("darkModeToggle").addEventListener("change", (e) => {
        document.body.classList.toggle("dark-mode", e.target.checked);
    });

    document.addEventListener('keydown', (e) => {
        if (!pdfDoc) return;
        
        if (e.key === 'ArrowLeft' && currentPdfPage > 1) {
            renderPdfPage(currentPdfPage - 1);
        } else if (e.key === 'ArrowRight' && currentPdfPage < pdfDoc.numPages) {
            renderPdfPage(currentPdfPage + 1);
        } else if (e.key === '+' || e.key === '=') {
            e.preventDefault();
            zoomInBtn.click();
        } else if (e.key === '-') {
            e.preventDefault();
            zoomOutBtn.click();
        }
    });

    // Initialize the page
    window.addEventListener('load', () => {
        if (!getAuthToken()) {
            showError('Please login to access books.');
            setTimeout(() => {
                window.location.href = 'login.html';
            }, 2000);
            return;
        }
        
        loadBook().then(() => {
            loadSavedProgress();
            if (pdfDoc) {
                renderPdfPage(currentPdfPage);
            }
        });
    });

    // Debug function to check element visibility
function debugVisibility() {
    console.log('PDF Container display:', pdfContainer.style.display);
    console.log('PDF Container visibility:', pdfContainer.style.visibility);
    console.log('PDF Container computed display:', window.getComputedStyle(pdfContainer).display);
    console.log('Canvas width:', pdfCanvas.width, 'height:', pdfCanvas.height);
    console.log('Canvas client width:', pdfCanvas.clientWidth, 'client height:', pdfCanvas.clientHeight);
    console.log('Canvas offset width:', pdfCanvas.offsetWidth, 'offset height:', pdfCanvas.offsetHeight);
}


  </script>
</body>
</html>